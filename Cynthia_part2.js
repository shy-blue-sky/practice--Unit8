/**
 * Let's use higher order functions like map, filter, and reduce to gather information
 * and manipulate some data. Here we are importing historical Bitcoin data from 2013 to 2015.
 * Each object contains information like price, market cap, fees, and much more.
 * Let’s see what information we can extract using higher order functions!
 *
 * First, let's import the data. bitcoinData is initialized in the file bitcoinData.js -
 * you can open the file and check it out!
 * After importing it, we can work with bitcoinData just as if we had created it in this file.
 *
 * Don't forget to test your code as you go using console-logs.
 */
// const bitcoinData = require('./bitcoinData.js'); // imports const bitcoinData from .js file

const bd = [
  {
    date: '2013-05-01',
    'txVolume(USD)': 108659660.293,
    txCount: 52443,
    'marketcap(USD)': 1542820000,
    'price(USD)': 139,
    'exchangeVolume(USD)': 0,
    generatedCoins: 3575,
    fees: 36.80599998,
    activeAddresses: null,
  },
  {
    date: '2013-05-02',
    'txVolume(USD)': 96958519.0041,
    txCount: 55169,
    'marketcap(USD)': 1292190000,
    'price(USD)': 116.38,
    'exchangeVolume(USD)': 0,
    generatedCoins: 3425,
    fees: 54.40791613,
    activeAddresses: null,
  },
  {
    date: '2013-05-03',
    'txVolume(USD)': 84459697.3245,
    txCount: 55636,
    'marketcap(USD)': 1180070000,
    'price(USD)': 106.25,
    'exchangeVolume(USD)': 0,
    generatedCoins: 3650,
    fees: 48.52677208,
    activeAddresses: null,
  },
  {
    date: '2013-05-04',
    'txVolume(USD)': 41545844.5296,
    txCount: 48595,
    'marketcap(USD)': 1089890000,
    'price(USD)': 98.1,
    'exchangeVolume(USD)': 0,
    generatedCoins: 3900,
    fees: 43.41969441,
    activeAddresses: null,
  }]

/**
 * Challenge 1:
 *
 * Log the bitcoinData object to investigate the structure of our data.
 * What is the data type of bitcoinData?
 * Let’s say we just want to look at bitcoin information on May 1st, 2013. How can we do that?
 */
// console.log(typeof bd);


 const may1Data = bd.filter( el => el.date === '2013-05-01');  
 

// console.log(may1Data);

/**
 * Challenge 2:
 *
 * Use the built-in map method to create an array containing only the date and price of each day.
 */

// const dp = bd.map( (el) => {
//     const x = [ el.date, el['price(USD)'] ]; // how to refer to key with ()
//     // put date and price into own array
//     return x; 
// }).flat(); // chain flat() to map to get rid of 1 level nesting

//better solution
// just add objects containing date and price into the arr, automatically generated by map()
const dp = bd.map((el) => ( 
  { 
  date: el.date,
  price: el["price(USD)"],
  }
));

// console.log(dp);


/**
 * Challenge 3:
 *
 * Create an array that only includes days when exchange volume was not 0.
 * Which method should we use?
 */

const goodDay = bd.filter( (el) => el['exchangeVolume(USD)'] !== 0);

// console.log(goodDay);

/**
 * Challenge 4:
 *
 * Calculate how many new Bitcoins were generated altogether during the time
 * provided in the dataset using reduce.
 */


const genCoin = bd.reduce( (acc, curr) => {
    return acc + curr.generatedCoins; 
}, 0) 

// acc is placeholder for result of each iteration!! so it will overwrite the original initial value or data type that it was at the 1st iteration
// must have initial value here so that it doesn't have acc as an obj, since it would automatically take value of 1st obj. Instead, we need acc = 0 (as a number) since when iterating, the result will be a number every time

// console.log(genCoin);



/**
 * Challenge 5:
 *
 * Find the total number of days when the bitcoin price was over $100 by
 * combining some array methods.
 */

const price100 = bd.filter ( (el) => el['price(USD)'] > 100);
// console.log(price100.length);


/**
 * Challenge 6:
 *
 * Find the average bitcoin transaction fees between 2013 and 2015.
 * Be sure to floor this value.
 */

const patterns = /2013|2014|2015/g // regex, g refers to global search

const feesBtwn = bd.filter( (el) => el.date.match(patterns) )

const sumFees = feesBtwn.reduce( (acc, curr) => {
    return acc + curr.fees;
}, 0);

// const avgFees = Math.floor(sumFees/feesBtwn.length);

// // console.log(feesBtwn);
// console.log(sumFees);
// console.log(avgFees);

/**
 * Challenge 7:
 *
 * Write a function called dayMapper that accepts three parameters:
 * arr (bitcoinData), property1, property2.
 * It should use map to return a new array of objects with only the passed-in
 * properties on each object.
 * If the passed-in properties are not present in arr's objects, they should be
 * ignored in the returned array.
 */

// function dayMapper (arr, property1, property2) {
//     const dayMap = arr.map ( (el) => {
//         if (Object.keys(el).includes(property1) === true && Object.keys(el).includes(property2) === true) return [el[property1], el[property2]];
//     } )
//     return dayMap.flat();
// }

//better solution to return nested obj inside array

function dayMapper(arr, prop1, prop2) {
  return arr.map((item) => {
    const result = {};
    if (item[prop1] !== undefined) { // if value of obj prop1 is NOT undefined
      result[prop1] = item[prop1];
    }
    if (item[prop2] !== undefined) { // if value of obj prop2 is NOT undefined
      result[prop2] = item[prop2];
    }
    return result;
  });
}


// console.log(dayMapper (bd, 'date', 'fees'));


/**
 * Challenge 8:
 *
 * For each property that has numeric values in bitcoin data, write a function
 * that takes in an 'arr' (bitcoinData in this case) and a property 'name' and
 * returns the property's average value in the array.
 */

function avgNum (arr, propName) {
    const x = arr.filter( (el) => typeof el[propName] === 'number' ); // include only prop with numeric val
    const y = x.reduce( (acc, curr) => { // x is all objects with propName as number type
       return acc + curr[propName];
    }, 0);
    return y/x.length;
}

// function avgNum (arr, name) {
//   let isError = false;
//   const { sum, count } = arr.reduce( (acc, currObj) => {
//     if (typeof currObj[name] === 'number') {
//       acc.sum += currObj[name];
//       acc.count++;
//     } else {
//       console.log('error!');
//       isError = true;
//     }
//     return acc;
// }, {sum: 0, count: 0} );
//    if (count === 0) {
//     return 'not a prop with numeric value';
//    } else {
//     return sum / count;
//    }
// }

// console.log(avgNum(bd, 'fees'));


/**
 * Challenge 9:
 *
 * Write a function called generalAverageValue that takes two parameters: arr and property.
 * The function should check to ensure that the property's values are numeric. If they aren't,
 * it should return an error message. Otherwise, it should return an array
 * of the form [property, avgValue].
 */

//write func with 2 input par: arr and prop
// check that prop vals are numeric
//if not, return error msg
// else return an arr in form [prop, avgVal]

// obj destructuring: const { sum, count } 
  // take obj returned by reduce() and pull out its sum property, store in variable called sum
  // pull out its count property, store in variable called count 
  // const does declare variables — here, it declares 2 variables: sum and count.

// The { sum, count } part is destructuring syntax telling JavaScript:
// “Take the sum property from this object and store it in a variable called sum.
// Take the count property from this object and store it in a variable called count.”

function genAvgVal (arr, prop) {
  const { sum, count } = arr.reduce( (acc, curr) => {
    if (typeof curr[prop] === 'number') {
      acc.sum += curr[prop];
      acc.count++;
      } else {
      console.log('error');  
      }
    return acc;
  }, {sum: 0, count: 0})
  
  if (count === 0) {
    return 'not a numeric property'
  } else {
    return [prop, sum/count];
  }
}

// console.log(genAvgVal(bd, 'fees'));


/**
 * Challenge 10:
 *
 * Write a function called priceRangeTally which accepts one argument, arr.
 * The function should:
 * - Find the maximum bitcoin price
 * - Find the minimum bitcoin price
 * - Choose an arbitrary interval to create ranges (either dynamically or hard-coded)
 * - Tally how many days of bitcoin prices fall into each range
 * - Console.log a nicely formatted string of each interval and how many days fall into each interval.
 * The function doesn't have to return anything, but it can return a tally object or array if desired.
 */

//write func prRangTally, accepts 1 arg arr
// finds max btc price
// min btc price
// choose arbitrary interval to create price ranges
// count how many days between each price range
// print str of each range and how many days fall into each range
// func no need to return any value, except maybe tally obj or arr if desired

// function prRangeTally (arr) {
//   const newArr = [];
//   for (const currObj of arr) {
//     newArr.push(currObj['price(USD)']);
//   }
//   return newArr;
//   // return mx;
// }

// function prRangeTally (arr) {
//   const prMap = arr.map( (currObj) => currObj['price(USD)']);
//   console.log(Math.max(...prMap));
//   console.log(Math.min(...prMap));
//   const prRange = arr.filter( (obj) => 100 <= obj['price(USD)'] <= 115 );
//   return `There were ${prRange.length} days when BTC's price was between $100 to $115.`
// }

//from Manny / Arsy
const prices = bd.map((data) => data["price(USD)"]);

const priceRangeTally = (arr, int = 0) => {
  if (!Array.isArray(arr) || arr.length === 0) {
    console.log("Error: Invalid array");
    return;
  }

  let minPrice = Infinity;
  let maxPrice = -Infinity;

  arr.forEach((day) => {
    if (typeof day["price(USD)"] === "number") {
      minPrice = Math.min(minPrice, day["price(USD)"]);
      maxPrice = Math.max(maxPrice, day["price(USD)"]);
    }
  });

  if (minPrice === Infinity || maxPrice === -Infinity) {
    console.log("no valid prices found");
    return;
  }

  const tally = {};

  //populate tally obj

  arr.forEach((day) => {
    if (typeof day["price(USD)"] === "number") {
      const rangeStart = Math.floor(day["price(USD)"] / int) * int;

      const rangeKey = `${rangeStart} - ${rangeStart + int - 1}`;

      tally[rangeKey] = (tally[rangeKey] || 0) + 1;
    }
  });

  console.log(`Min Price: ${minPrice}`);
  console.log(`Max Price: ${maxPrice}`);
  console.log("-------------------------------");

  for (const range in tally) {
    console.log(`${range}  | Days: ${tally[range]}`);
  }
};

// console.log(prRangeTally(bd));
priceRangeTally(bd, 100);

/**
 * Challenge 11:
 *
 * Write a function that will accept an array (bitcoinData) as a parameter and return an object
 * with keys that are the names of all the numerical properties of the bitcoinData objects,
 * and whose values are the max values of those properties.
 */

function findPropMax(arr) {
  if (!Array.isArray(arr) || arr.length === 0) {
    return {};
  }
  const maxValues = arr.reduce((acc, curr) => {
    Object.keys(curr).forEach((key) => {
      const value = curr[key];

      if (acc[key] == undefined || value > acc[key]) {
        acc[key] = value;
      }
    });
    return acc;
  }, {});

  return maxValues;
}

// console.log(findPropMax(bd));

/**
 * Challenge 12:
 *
 * Do the same as Challenge 11, but for minimum values.
 */

function findPropMin2(arr) {
  if (!Array.isArray(arr) || arr.length === 0) {
    return {};
  }
  const minValues = arr.reduce((acc, curr) => {
    Object.keys(curr).forEach((key) => {
      const value = curr[key];

      if (acc[key] == undefined || value < acc[key]) {
        acc[key] = value;
      }
    });
    return acc;
  }, {});

  return minValues;
}

// console.log(findPropMin2(bitcoinData));
// /**

// console.log(findPropMin(bd));

/**
 * Challenge 13:
 *
 * Write a function valueRanges that will accept an array (bitcoinData) and return an object
 * with keys that are the names of all the numerical properties of the bitcoinData objects.
 * The values for each key should be their ranges for any object in the input array '<min> to <max>'.
 *
 * HINT: You can use the minValues and maxValues functions you wrote earlier.
 */


function valueRanges(arr) {
  const minValues = findPropMin2(bitcoinData);
  const maxValues = findPropMax2(bitcoinData);

  const ranges = {};

  for (const key in minValues) {
    const min = minValues[key];
    const max = maxValues[key];

    ranges[key] = `${min} to ${max}`;
  }

  return ranges;
}

// console.log(valueRanges(bitcoinData));


//random experiments

// const things = [1, 2, 3, 4, 5];
// const word = `${[...things]}`;
// console.log(word);


// const random = ['hi', 'bye', 'hello'];
// const word1 = `${[...random]}`;
// console.log(word1);

// const randomObj = {...random};
// console.log(randomObj);

